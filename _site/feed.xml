<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scott Davis</title>
    <description>Developer / Designer
</description>
    <link>http://sco.ttdavis.com/</link>
    <atom:link href="http://sco.ttdavis.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 06 Jan 2016 09:59:52 -0500</pubDate>
    <lastBuildDate>Wed, 06 Jan 2016 09:59:52 -0500</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Caching model associations in rails</title>
        <description>&lt;p&gt;I’ve been working on a project recently called &lt;a href=&quot;http://www.explorableplaces.com&quot;&gt;www.explorableplaces.com&lt;/a&gt;, and I added memcached caching with &lt;a href=&quot;https://github.com/mperham/dalli&quot;&gt;Dalli&lt;/a&gt;. So I’m basically trying to cache anything and everything that can help our performance.&lt;/p&gt;

&lt;p&gt;Normally, you will see guides and articles show you caching with an example like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cached_images&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;Rails&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Articles&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;images&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;updated_at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;to_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;images&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;to_a&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;And while this now works, if I eager load an association, it will not &lt;!--more--&gt; call my “images_cached” method but the default one instead, so no gain there.&lt;/p&gt;

&lt;p&gt;When I was thinking about this more and more, a lightbulb went off in my head. Instead, you can do something like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Article&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ActiveRecord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Base&lt;/span&gt;
  &lt;span class=&quot;ss&quot;&gt;has_many: :images&lt;/span&gt;
  &lt;span class=&quot;ss&quot;&gt;has_many: :cached_images&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;class_name: &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Image&quot;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cached_images&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;Rails&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Articles&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;images&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;updated_at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;to_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;to_a&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;so-whats-going-on-here&quot;&gt;So What’s Going On Here?&lt;/h2&gt;

&lt;p&gt;This adds a new association that basically just returns all an article’s images. So why did I create a new one? Well we still need our controllers to work with creating new images like “@article.images.new”. Also, the advantage here is now I can eager load images: “Article.all.includes(:cached_images)” which will return all cached images with each article.&lt;/p&gt;

&lt;p&gt;When it’s run, rails tries to fetch it from the cache using a key created from the array of values passed into it. If it finds something, it returns it. And if not, it runs the code in the block and returns that (which is then cached for future use). In that block, super just calls the original “images” method to make the call to the db and get those images.&lt;/p&gt;

&lt;h2 id=&quot;updatedat-what-are-these-keys&quot;&gt;Updated_at? What Are These Keys?&lt;/h2&gt;

&lt;p&gt;Why do I have “updated_at” in there? Basically, once the model is updated, this would mean the key would be updated, and essentially expire the old cached value, fetching a new one. This is a safer feature so your data doesn’t get stale. For our example, if the article has an id of 5, then our key would look something like “Articles/5/images/1448145415”.&lt;/p&gt;

&lt;p&gt;You may have wondered, what if I update an image? Then the cache will not be expired but I will still get old data? We can easily fix that in our images model:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Image&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ActiveRecord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Base&lt;/span&gt;
  &lt;span class=&quot;ss&quot;&gt;belongs_to: :article&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;touch: &lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With “touch: true”, whenever the image is created, updated or destroyed, it will touch the article it belongs to, updating its “updated_at” time. Sweet!&lt;/p&gt;

&lt;h2 id=&quot;and-toa&quot;&gt;And To_a?&lt;/h2&gt;

&lt;p&gt;And you may also be wondering why “.to_a”. Well, without that, it will actually just cache the ActiveRecord association and not the values. That’s bad, and would just throw an error on us if we try to retrieve it. Calling “to_a” on it forces that association to actually make the call and get our data, which is returned as an array so we can cache it.&lt;/p&gt;

&lt;p&gt;That’s it, hope you found this as useful as I did!&lt;/p&gt;

</description>
        <pubDate>Wed, 25 Nov 2015 19:02:31 -0500</pubDate>
        <link>http://sco.ttdavis.com/blog/caching-model-associations-in-rails</link>
        <guid isPermaLink="true">http://sco.ttdavis.com/blog/caching-model-associations-in-rails</guid>
        
        
      </item>
    
  </channel>
</rss>
